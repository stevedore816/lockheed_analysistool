package vulnerabilityDetector;

import codeInterpration.CodeInterpreter;

import java.util.Set;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class cppAnalyzer extends Analyzer {
	
	/* This method should work by looking at inputs of C++ code
	 * Use regex expressions in order to find blocks of information and data for input values and find out if these
	 * instances make the system vulnerable or not
	 * mysql_query[(]( |)([A-Za-z0-9]+),( |)('|")SELECT.+FROM.+('|").*..*( |)[)]
	 */
	public void checkInputValidation() {
		//this code will check for special instances of cpp queries before refering to its parent method
		ArrayList<String> queries = CodeInterpreter.searchCode("mysql_query[(]( |)([A-Za-z0-9]+),( |)('|\")SELECT.+FROM.+('|\").*..*( |)[)]");
			for (String searches : queries) {
				if (CodeInterpreter.searchCode(searches, "=( |)'").size() > 0) {
					cyberAttacks.add(new attackVector(searches, Type.INPUTVALIDATION));
				}
			}  
			super.checkInputValidation();
		
	}
	
	/* This method will look for instances in memory where there is no instance of the memory getting deleted
	 * Using Regex you can find the instances of memory that does not have a following delete key and we can decide from there if 
	 * This makes the system vulnerable or not
	 */
	public void checkMemoryLeak(String code) {
		//cyberAttacks.add(new attackVector(Type.MEMORYLEAK)); 
		//Look for any for loop code blocks and check for mem leak inside that block first
		code = code.replaceAll("\\ {1,3}\\n","\\ {4}\\n"); //Extend lines with only <4 spaces to have 4 spaces for regex to work
		code = code.replaceAll("\\n\\n","\\n\\ {4}\\n"); //Extend blank lines to have 4 spaces for regex to work
		String forLoopRegex = "(\\s*)for\\(.*(?:\n\\1.*)*\n\\1\\}";
		
		code = refineForLoop(code);
		ArrayList<String> forLoops = CodeInterpreter.searchCode(code, forLoopRegex);
		for(String forLoop: forLoops){
			int start = forLoop.indexOf('{') +1;
			int end = forLoop.length()-1;
			checkMemoryLeak(forLoop.substring(start,end)); //Analyze the code block with out the "for(;;){}" heading
			code = code.replace(forLoop,"");//Remove the code block to not get re-analyzed below
		}
		
		//Look for Mem allocation
		String regex1 = "[A-Za-z0-9]*\\s*=\\s*new";
		ArrayList<String> results = CodeInterpreter.searchCode(code, regex1);
		ArrayList<String> varNames = new ArrayList<>();
		// Trim the string, leaving only the varName
		int len = results.size();
		for(int i=0; i<len; i++){
			varNames.add( getVarName( results.get(i) ) );
			
		}
		Set<String> vars = new HashSet<String>(varNames); 
		//Check it's deallocated
		
		for(String varName: vars){
			String regex2 = "delete\\s*(\\(|\\[\\])?\\s*"+varName;
			String allocRegex = varName+"\\s*=\\s*new";
			int numDeallocs = CodeInterpreter.searchCode(code,regex2).size();
			int numAllocs = CodeInterpreter.searchCode(code,allocRegex).size();
			
			
			if(CodeInterpreter.searchCode(code,regex2).isEmpty()){
				//varName has not been deallocated");
				int index = varNames.indexOf(varName);
				String regexLine = results.get(index);
				int[] pos = CodeInterpreter.getLocation(code, regexLine);
				cyberAttacks.add(new attackVector(pos[0],pos[1], Type.MEMORYLEAK, regexLine));
			}
			else if(numAllocs!= numDeallocs){
				//There's a leaked memory that hasnt been deallocated 
				cyberAttacks.add(new attackVector(Type.MEMORYLEAK));
			}
		}
	}
	
	private static String getVarName(String s){
		//find location of the '='
		s = s.replaceAll("\\s","");
		int len = s.length();
		int i = 0;
		while(i<len){
			if(s.charAt(i)!='='){}
			else{break;}
			i++;
		}
		return s.substring(0,i);
	}
	
	private String refineForLoop(String code) {
	    String regex = "\\ +for\\(";
		Pattern string = Pattern.compile(regex);
		Matcher matcher = string.matcher(code);  
		while (matcher.find()) {
		    int len = matcher.group().length();
		   code = matcher.replaceAll( getString(matcher.group()) ); 
		  
		}
		return code;
	}	
	
	private String getString(String code){
	    StringBuilder str = new StringBuilder();
	    int f = code.indexOf('f');
	    int n = code.substring(0,f).length();
	    if(n>1){str.append(String.format("%1$"+(n-1)+"s",""));}
	    str.append('\n');
	    str.append(String.format("%1$"+(n)+"s", ""));
	    str.append(code.substring(f,code.length()));
	    String s = str.toString();
	    return s;
	}
}
