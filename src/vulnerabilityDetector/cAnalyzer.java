
package vulnerabilityDetector;

import codeInterpration.CodeInterpreter;

import java.util.Set;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
/*
	 NOTE TO SELF:
	 MEM LEAK IS INCOMPLETE: NOT ONLY DETECT FREE(VAR), BUT ALSO # MALLOC(VAR) = # FREE(VAR)

	 IF MEM LEAK IS NOT DETECTED ONLY, CHECK DEALLOCATED BEFORE REALLOCATING

	 DELETE THIS COMMENT AFTER RESOLVING THE ISSUES ABOVE

 */
public class cAnalyzer extends Analyzer{

	/* This method should work by looking at inputs of C code
	 * Use regex expressions in order to find blocks of information and data for input values and find out if these
	 * instances make the system vulnerable or not
	 */
	public void checkInputValidation() {
		ArrayList<String> queries = CodeInterpreter.searchCode("( |)('|\"|)SELECT.+FROM.+('|\").*..*( |)( |\n)");
		for (String searches : queries) {
			if (CodeInterpreter.searchCode(searches, "=( |)'").size() > 0) {
				cyberAttacks.add(new attackVector(searches, Type.INPUTVALIDATION));
			}
		}  		
		super.checkInputValidation();
	}

	/*
	 * Method to find possible buffer overflow vulnerabilities. This is done by looking for known c methods that do not check bounds and can be exploited.
	 * This is not a catch all, as memory could be incorrectly allocated in for/while/dowhile loops. Also, does not check if there is correct input validation
	 * before allocation. 
	 */
	public void checkBufferOverflow() {
		ArrayList<String> buffMethods = CodeInterpreter.searchCode("[^\"](gets|strcpy|strcat|sprintf|strlen|strcmp)[(].*[)];");
		for(String searches : buffMethods) {
			attackVector temp = new attackVector(searches, Type.BUFFEROVERFLOW);
			if(searches.contains("gets")) {
				temp.setReason("Does not check for buffer overflows. Use fgets() instead.");
			}
			else if(searches.contains("strcpy")) {
				temp.setReason("Does not check for buffer overflows when copying to destination \r\n" + 
						"  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\r\n" + 
						"  easily misused)..");
			}
			else if(searches.contains("strcat")) {
				temp.setReason("Does not check for buffer overflows when concatenating to destination\r\n" );
			}
			else if(searches.contains("sprintf")) {
				temp.setReason("Does not check for buffer overflows. Use sprintf_s, snprintf, or\r\n" + 
						"  vsnprintf.");
			}
			else if(searches.contains("strlen")) {
				temp.setReason("Does not handle strings that are not \\0-terminated; if given one it may\r\n" + 
						"  perform an over-read (it could cause a crash if unprotected)");
			}
			else if(searches.contains("strcmp")) {
				temp.setReason("Does not handle strings that are not \\0-terminated; if given one it may\r\n" + 
						"  perform an over-read (it could cause a crash if unprotected), consider using strncmp");
			}
			cyberAttacks.add(temp);
		}
	}
	
	/*
	 * Check code for improper use of print function in c, these can lead to a format string vulnerability. This would allow an attacker to pass
	 * commands to the application, as the application will not properly validate the submitted input. Using regex method will search for print functions
	 * and after location all of said functions, helper method getNonFormated will be called to pull all non formated functions. 
	 */	
	public void checkStringFormat() {
		ArrayList<String> stringFormat = CodeInterpreter.searchCode("([A-Za-z]*print[f])[(].*[)];");
		stringFormat = getNonFormated(stringFormat);
		for(String code : stringFormat) {
			cyberAttacks.add(new attackVector(code, Type.STRINGFORMAT,"If format strings can be influenced by an attacker, they can be exploited \r\n" +
					  ". Use a constant for the format specification.)" ));
		}
	}

	/* This method will look for instances in memory where there is no instance of the memory getting deleted
	 * Using Regex you can find the instances of memory that does not have a following delete key and we can decide from there if 
	 * This makes the system vulnerable or not
	 */
	public void checkMemoryLeak(String code) {
		//cyberAttacks.add(new attackVector(Type.MEMORYLEAK)); 
		//Look for any for loop code blocks and check for mem leak inside that block first
		code = code.replaceAll("\\ {1,3}\\n","\\ {4}\\n"); //Extend lines with only <4 spaces to have 4 spaces for regex to work
		code = code.replaceAll("\\n\\n","\\n\\ {4}\\n"); //Extend blank lines to have 4 spaces for regex to work
		String forLoopRegex = "(\\s*)for\\(.*(?:\n\\1.*)*\n\\1\\}";

		code = refineForLoop(code);

		ArrayList<String> forLoops = CodeInterpreter.searchCode(code, forLoopRegex);
		for(String forLoop: forLoops){
			int start = forLoop.indexOf('{') + 1;
			int end = forLoop.length() - 1;
			checkMemoryLeak(forLoop.substring(start,end)); //Analyze the code block with out the "for(;;){}" heading
			code = code.replace(forLoop,"");//Remove the code block to not get re-analyzed below
		}

		//Look for Mem allocation
		String regex1 = "[A-Za-z0-9]+\\s*=.*(m|c)alloc";
		ArrayList<String> results = CodeInterpreter.searchCode(code, regex1);
		ArrayList<String> varNames = new ArrayList<>();

		// Trim the string, leaving only the varName
		int len = results.size();
		for(int i=0; i<len; i++){
			varNames.add( getVarName( results.get(i) ) );
		}
		Set<String> vars = new HashSet<String>(varNames);


		//Check it's deallocated
		for(String varName: vars){
			String regex2 = "(free|realloc)\\s*\\(\\s*"+varName;
			String allocRegex = varName+"\\s*=.*(m|c)alloc";
			int numDeallocs = CodeInterpreter.searchCode(code,regex2).size();
			int numAllocs = CodeInterpreter.searchCode(code,allocRegex).size();
			int index = varNames.indexOf(varName);
			String regexLine = results.get(index);
			int[] pos = CodeInterpreter.getLocation(code, regexLine);
			if(numDeallocs==0){
				// varName's memory has not been deallocated at least once	
				cyberAttacks.add(new attackVector(regexLine, Type.MEMORYLEAK));
			}
			else if(numAllocs!= numDeallocs){
				//There's a leaked memory that hasnt been deallocated 
				cyberAttacks.add(new attackVector(regexLine, Type.MEMORYLEAK));
			}
		}
	}
	
	/*
	 * Method will take an array of printf and similar statement and find those that are not formated and return them in an array
	 * @param ArrayList of code lines with printf statements
	 * @return Arraylist containing all non formated printf statements. 
	 */
	public ArrayList<String> getNonFormated(ArrayList<String> list){
		
		ArrayList<String> nonFormated = new ArrayList<String>();
		for(String looking : list) {
			if(!looking.matches("([A-Za-z]*print[f])[(].*(\"%[spdcuxn].*\").*[)];")) {
					nonFormated.add(looking);
			}
		}
		return nonFormated;
	}

	private static String getVarName(String s){
		//find location of the '='
		s = s.replaceAll("\\s",""); //get rid of all whitespaces
		int len = s.length();
		int i = 0;
		while(i<len){
			if(s.charAt(i)!='='){}
			else{break;}
			i++;
		}
		return s.substring(0,i);
	}

	private String refineForLoop(String code) {
		String regex = "\\ +for\\(";
		Pattern string = Pattern.compile(regex);
		Matcher matcher = string.matcher(code);  
		while (matcher.find()) {
			int len = matcher.group().length();
			code = matcher.replaceAll( getString(matcher.group()) ); 

		}
		return code;
	}	

	private String getString(String code){

		StringBuilder str = new StringBuilder();
		int f = code.indexOf('f');
		int n = code.substring(0,f).length();
		if(n>1){str.append(String.format("%1$"+(n-1)+"s",""));}
		str.append('\n');
		str.append(String.format("%1$"+(n)+"s", ""));
		str.append(code.substring(f,code.length()));
		String s = str.toString();
		return s;

	}

}