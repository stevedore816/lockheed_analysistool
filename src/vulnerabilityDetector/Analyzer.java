package vulnerabilityDetector;

import java.util.ArrayList;

import codeInterpration.CodeInterpreter;

public class Analyzer {
	
	// This is where the CodeInterpreter is used and refers to the original deciphered code
	protected CodeInterpreter code;
	
	public Analyzer(CodeInterpreter code) {
		this.code = code;
		checkInputValidation();
		findRand();
	}
	
	/*
	 * This method should look for input validations inside of the variety of languages we go over
	 * The main method of doing this is by using regex expressions (Review if you need to) to try and detect the instances in the input 
	 * Where the input can be considered at risk or able to be attacked.
	 * 
	 * There should be no return value because you should be adding every type of attack to the cyberAttacks list with the type that it is
	 * and the location (eventually if you can find it focus on the functionality first though)
	 * 
	 * This algorithm will be the base case for all the algorithms that I make.
	 * Current only problem with this algorithm is that it double detects which is easy to get rid of 
	 * 
	 * look at the statement with the variable with it, if the statement has string concat or single quote check if theres a preparedstate
	 * if not for now add it to the list of input injections
	 * 
	 * 
	 * 
	 *(String|int|double|char|)\s([a-zA-Z0-9]+) = ('|")SELECT.+FROM.+('|").*..*
	 * 
	 * (prepareStatement|prepare|prepared|mysql_stmt_init)( |)( |)[(]( |)txtSQL( |)[)]
	 */
	public void checkInputValidation() {
		String regex = "(String|int|double|char|str|SELECT|)\\s([a-zA-Z0-9@]+)( |)(:|)=( |)('|\")SELECT.+FROM.+('|\").*..*";
		ArrayList<String> searchQuery = code.searchCode(regex);
		//cyberAttacks.add(new attackVector(Type.INPUTVALIDATION)); 
		for (String searches : searchQuery) {
				//Checks for String Concatenation (1 = 1 cases or ""="" cases) & for single quotes
			if (searches.contains("+") || searches.contains("'")) {
				//turns the previous regex into variables
				ArrayList<String> variables = code.searchCode(searches,"([a-zA-Z0-9]+) =");
				String variable = variables.get(0).replaceAll("\\s", "");
				variable = variable.substring(0, variable.length() - 1); 
				//check if preparedStatements exist
				ArrayList<String>preparedStatement = code.searchCode("(prepareStatement|prepare|prepared|mysql_stmt_init)( |)( |)[(]( |)"+ variable + "( |)[)]");
				//checks if any usaully form of string concat is happening
				ArrayList<String>amountfiltration = code.searchCode(searches, "=( |)(@|:) ");
				ArrayList<String>amountands = code.searchCode(searches, "AND");
				int[] pos = code.getLocation(searches);
				if(preparedStatement.size() == 0 && amountfiltration.size() != amountands.size()) code.addAttack(new attackVector(searches,Type.INPUTVALIDATION,"Try not to mix strings too much!"));
			}
		}
	} 
	/*
	* Random number generators such as the Random class in java and rand in C/C++ are not cryptographically strong. This means that
	* if said functions are used for authentication and authorization, such as a session ID or a seed for generating a cryptographic key, 
	* then an attacker may be able to easily guess the ID or cryptographic key and gain access to restricted functionality.
	* Regex will find any instance of use of these classes and warn the developer of the potential weaknes
	*/
	public void findRand() {
		String regex = ".*\\s*=\\s*.*(random|rand).*(\\().*(\\))(;)*";
		ArrayList<String> rand = code.searchCode(regex);

		for(String searches : rand) {
			cyberAttacks.add(new attackVector(searches,Type.RANDGEN, "Built in random number generators are not cryptographically strong, "
					+ "if used in a security context please consider better generators."));
		}
	}
}
